## 项目简介（Project Overview）

这是一个基于 Rust + Tokio + Reqwest 实现的 异步 HTTP 压力测试工具，支持 GET / POST 请求，可通过交互式命令行动态配置：
目标 URL
请求方法
并发线程数
单线程 QPS（请求速率）
工具在运行过程中持续发送请求，并在用户主动中断（Ctrl+C）后输出完整的性能统计结果，用于评估 Web 服务在指定负载下的响应稳定性与吞吐能力。

## 核心设计思想（Design Philosophy）
1. 不是“发得越多越好”，而是“发得有节制、发得可量化”。
2. 你没有走“无限 while + spawn 洪水”的野路子，而是做了三件很关键、很成熟的事：
3. 用 Tokio 实现真正的异步并发
4. 用 Semaphore 控制全局 QPS 上限
5. 用原子计数器做跨线程统计

## 功能说明（Features）
1️⃣ 交互式参数输入（支持默认值）
程序在每一轮测试前，都会提示用户输入：
`请求 URL
请求方法（GET / POST）
POST 请求体（可选）
并发线程数
单线程 QPS`
**并自动记住上一轮输入，避免重复输入参数，适合反复测试同一接口在不同负载下的表现。**

2️⃣ 基于 Tokio 的高并发请求模型

每一个“线程”本质上是一个 tokio::spawn 的异步任务

所有任务共享同一个 reqwest::Client，避免重复建立连接

每个任务在循环中持续发送请求，直到收到 Ctrl+C 信号

这是标准、正确、性能友好的 Rust 异步写法。

3️⃣ 全局 QPS 控制机制（核心亮点）

你不是简单地“sleep 1/qps”，而是：

计算 期望全局 QPS = 单线程 QPS × 线程数

使用 `tokio::sync::Semaphore` 限制同时发起的请求数量

每个请求获取一个 permit，完成后释放

这意味着：
即使线程数很多，也不会瞬间把目标服务打爆。
这是一个“软限流器”，在压力测试工具里非常重要。

4️⃣ 请求速率校正（时间片对齐）

每次请求都会记录开始时间，并在结束后：

计算请求耗时

若耗时小于 1 / qps，则主动 sleep 补齐时间

这一步保证了：

单线程请求频率稳定

不因网络波动导致请求密度失控

这是很多粗糙压测脚本完全不做的细节。

5️⃣ 原子级统计（无锁、线程安全）

程序使用：

AtomicUsize 统计成功请求数

AtomicUsize 统计失败请求数

避免了 Mutex 带来的性能损耗，同时保证统计数据在高并发下仍然准确。

6️⃣ 平滑中断与结果汇总

程序监听 Ctrl+C 信号：

不强杀任务

停止发送请求

统一计算并输出测试结果

最终统计信息包括：

成功请求数

失败请求数

实际运行时长

实际全局 QPS

与期望 QPS 的对比

这使得测试结果可复盘、可对比、可记录。

适用场景（Use Cases）

Web API 性能评估

服务限流策略验证

接口稳定性测试

学习 Rust 异步并发模型

教学或实验环境下的压力测试演示

使用说明（Usage）

运行程序

根据提示输入参数（或直接回车使用默认值）

程序开始持续发送请求

按 Ctrl+C 停止测试并查看统计结果

回车可进入下一轮测试

## 免责声明（Disclaimer）

本项目仅用于 合法、授权的性能测试、教学实验与技术研究用途。
严禁将本工具用于以下行为（包括但不限于）：
1. 未经授权的网络攻击或服务干扰
2. 对第三方系统实施拒绝服务（DoS/DDoS）
3. 任何违反当地法律法规或组织安全策略的行为
4. 使用本工具即表示使用者确认：
5. 已获得目标系统所有者的明确授权；
6. 明确知晓高并发请求可能对系统造成的负载影响；
因不当使用所导致的一切后果（包括法律责任、业务中断等）均由使用者自行承担。
本项目作者不对任何滥用行为承担责任。
